## 1. オープニング

今回のテーマは「ReScript基礎意味論と型安全」です。対象は、TypeScriptやJavaScriptでWeb開発をしているエンジニアの方です。このエピソードのゴールは、ReScriptの式中心モデルと静的型検査がなぜ有効なのか、その設計意図と使いどころを説明できる状態になることです。学習目標を一文で述べます。ReScriptの式中心モデルと静的型検査の価値を、TypeScriptとの違いで説明できるようになること。これが今回の到達点です。

(想定: 0.5分)

## 2. 前提を呼び起こす

まず、皆さんが普段使っているTypeScriptでの実装・設計パターンを振り返ります。JavaScriptやTypeScriptでは、式と文が混在した状態でコードを書くのが一般的です。数値はnumber型ひとつで扱い、条件分岐ではtruthyやfalsyといった暗黙の型変換を前提にした判定を日常的に行っています。

この慣習には二つの典型的な問題があります。一つ目は、型の不整合や暗黙変換に由来するバグが、実行時まで見つからないという点です。コンパイル時ではなく、テストを走らせるか本番環境で初めて発覚するケースが珍しくありません。二つ目は、数値型の区別が不足していること、そして条件式の判定が曖昧であることから、意図しない演算や分岐がコードに混入するという点です。整数と浮動小数点を区別しないまま演算した結果、想定外の丸め誤差が生じる。あるいは空文字列やゼロがfalsy扱いされて、本来通るべき分岐を通らない。こうした問題は現場で繰り返し発生しています。

(想定: 1分)

## 3. 結論を先に提示

先に結論を述べます。ReScriptが採用しているのは、式中心モデルと静的型検査を前提に、型推論を活用しつつ必要な箇所で型注釈を加えるというアプローチです。つまり、柔軟さを犠牲にするのではなく、推論で簡潔さを保ちながら、安全性が必要な境界には明示的に型を書く。この設計判断が、ReScriptの根幹にあります。

(想定: 0.5分)

## 4. 概念の最小モデル説明

ここからReScriptの基礎モデルを説明します。ReScriptがモデル化しているのは、値の評価、型の整合性、そして数値演算と条件分岐に関する安全な基礎ルールです。この三つを押さえれば、ReScriptの設計思想の骨格が見えてきます。

まず、値の評価について。ReScriptでは、すべての構文が式として評価されます。TypeScriptのように、値を返すものと返さないものが混在する構造ではありません。条件分岐も、ブロックも、すべてが評価されて値を返します。この一貫性が、コードの予測可能性を高めます。

次に、型の整合性について。ReScriptはコンパイル時に型の整合性を検査します。実行する前に不整合が検出される。この点がTypeScriptと決定的に異なります。TypeScriptにも型検査はありますが、anyやas、型アサーションによる抜け道が存在します。ReScriptにはそのような抜け道が基本的にありません。

そして、ReScriptが明示的に扱える領域を具体的に挙げます。第一に、整数と浮動小数点数の使い分けです。ReScriptではint型とfloat型が明確に区別されており、演算子も分離されています。整数の足し算と浮動小数点の足し算は異なる演算子で記述します。これにより、数値型の混同に起因するバグをコンパイル時に防げます。第二に、条件式にはbool型のみが使えるという制約です。TypeScriptのように、数値や文字列をそのまま条件に入れることはできません。この制約が、truthyやfalsyに起因する曖昧な分岐を排除します。第三に、比較演算は同じ型同士でなければ行えません。異なる型の値を比較しようとすると、コンパイルエラーになります。第四に、以上のすべてがコンパイル時に検出されるという点です。実行前に不整合が明らかになるため、テストに依存せずに安全性の一定水準を確保できます。

なお、このエピソードでは関数合成、再帰、モジュール、FFI、実装演習の詳細は扱いません。これらは後続のエピソードで順を追って説明します。

(想定: 3分)

## 5. 構造の捉え方

ここでは、TypeScriptとReScriptの構造的な違いを整理します。

TypeScriptやJavaScriptの実装慣習は、柔軟だが実行時に依存する検出が残るモデルと捉えられます。型を書くこともできるし、書かなくても動く。anyで逃げることもできる。この柔軟さは導入障壁を下げますが、その代償として、型由来のバグの検出タイミングが実行時まで後ろ倒しになるリスクを常に抱えています。

一方、ReScriptは式中心・厳格型・推論併用のモデルです。早期検出と設計の明確化を重視する構造になっています。型推論が強力であるため、記述量はTypeScriptと大きく変わりません。しかし、型の抜け道がないため、不整合はすべてコンパイル時に検出されます。

この違いが生む最大の変化は、判断タイミングの前倒しです。TypeScriptでは、型の問題に気づくのがコードレビュー時かテスト実行時、あるいは本番障害時になりがちです。ReScriptでは、コードを書いた瞬間にコンパイラが型の不整合を指摘します。つまり、問題の発見と修正が、開発サイクルの最も早い段階に移動します。設計の意図が型として表現されているため、コードを読むだけでその意図が伝わる。レビューでも「この型は何を意味しているか」が議論の出発点になります。判断の根拠が、実行結果ではなく型構造に置かれることで、開発プロセス全体の見通しが変わります。

(想定: 3分)

## 6. 思考を促す問いかけ

ここで一つ、考えてみてください。あなたが今関わっている既存のTypeScriptコードベースで、バグの予防と設計の見通しを優先して、新しい言語の導入を検討するとします。その初期判断として、何を基準に評価しますか。

（3秒沈黙）

判断基準は、好みや流行ではなく、設計原則に寄せてください。「この言語を採用することで、コンパイル時にどれだけの不整合を検出できるか」「型の構造が設計意図をどの程度表現できるか」。その観点で評価することが、導入判断の精度を上げます。

(想定: 1分)

## 7. 実務への接続

実務における具体的な効果を三点述べます。

第一に、レビュー時点で型に由来する不具合の候補を減らせるということです。コンパイラが事前に型の不整合を弾いているため、レビューで確認すべき項目から型エラーの大部分が除外されます。実行前に安全性を担保しやすくなり、レビューをロジックや設計判断に集中させることができます。

第二に、コードレビューの運用が変わります。具体的には、型注釈を必須とする箇所と、型推論に任せる箇所を明確に分ける運用に切り替えます。関数の公開インターフェースには型注釈を必須とし、ローカル変数や内部処理は推論に委ねる。このルールを設けることで、注釈の過不足に関する議論がなくなり、レビューの観点が統一されます。

第三に、保守性とリスクへの影響です。暗黙変換や曖昧な条件に起因する保守リスクが低減されます。型が明示的であるため、コードを変更した際の影響範囲をコンパイラが教えてくれます。変更時の影響把握が容易になり、リファクタリングへの心理的障壁が下がります。

(想定: 1.5分)

## 8. まとめ

最後に、今回の内容を踏まえて早期に決めるべきことを整理します。

決めるべきことは三つです。数値型の扱い方針、型注釈のポリシー、条件式の記述規約。この三つをチーム内で合意しておくことで、ReScriptの型安全の恩恵を最大限に引き出せます。

今回の内容が適用できる範囲は、Webアプリのドメインロジックと変換処理の基礎部分です。すべてのレイヤーに一度に適用する必要はありません。まずはドメインの中核となるロジックから始めるのが妥当です。

なお、具体的な関数型設計テクニックと実務移行手順の詳細は、次回以降で扱います。今回は、実装演習や環境構築手順の詳細には入っていませんし、チャプター2以降の高度な関数合成も対象外です。これらは今後のエピソードで段階的にカバーしていきます。

(想定: 1分)

合計想定時間: 約10.5分
